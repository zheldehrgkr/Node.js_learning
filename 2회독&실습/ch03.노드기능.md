# 03-1. 노드 기능과 내장 객체

## REPL

read, eval, print, loop 의 4단계를 실행하는 REPL을 진행하여 터미널에서 즉석에서 js 코드 실행이 가능하다.

```bash
$ node
> // js 코드
```

## js 파일 실행하기

js 파일을 만든 후 터미널에서 node [파일경로]로 실행할 수 있다.

```js
// 디렉토리/hello.js

console.log('hello node!');
```

```bash
// 해당 디렉토리에서
$ node hello
hello node!
```

## 모듈

코드를 모듈로 만들 수 있다. ES6에서 추가된 js의 모듈과는 다른 노드만의 모듈 시스템이다.

노드는 **module.exports라는 객체를 가지고 있으며 이 객체는 처음에는 비어있다.**  
이제 모듈에 이것저것 추가해보자.

```js
// exam.js
const yes = '변수';
const obj = { a: 1 };
function add(x, y) {
  return x + y;
}

module.exports = { yes, obj, add };
```

module.exports 는 yes, obj, add 3개의 프로퍼티(or 메서드)를 가진 객체가 되었다. module.exports 에 객체만 대입할 수 있는 것은 아니며, 변수나 함수도 대입이 가능하다. (다만 그렇게 되면 하나밖에 내보내지를 못 하겠지)

불러올때는 require() 를 사용하면 된다. require(경로)는 경로에 있는 module.exports 객체를 반환한다.  
그럼 객체를 얻었으므로 두 가지 방법으로 불러올 수 있을 것이다. 먼저 객체를 변수에 저장하는 방법. 내보낸 것들이 객체의 프로퍼티로 존재하므로 . 연산자를 사용해서 접근하였다.

```js
// 같은 폴더
// require.js
const exmaple = require('./exam');

console.log(exmaple.obj); // { a: 1 }
console.log(exmaple.add(1, 2)); // 3
```

디스트럭처링 할당을 사용하는 두번째 방법. 각 변수에 프로퍼티가 할당되었으므로 변수 이름을 바로 사용한다.

```js
// 같은 폴더
// require.js
const { yes, obj, add } = require('./exam');

console.log(obj); // { a: 1}
console.log(add(1, 2)); // 3
```

만약에 module.exports 에 변수나 함수를 대입했다면 그냥 이름으로만 사용해야 할 것이다.

```js
// exam.js
function add(x, y) {
  return x + y;
}

module.exports = add;

// require.js
const add = require('./exam'); // 변수이름은 아무거나 해도 상관없음

console.log(add(1, 2)); // 3
```

아 이게 계속 헷갈렸었는데 정리하니까 개운하다!

## 내장 객체

별도 설치가 필요없는 내장 객체와 모듈을 지원한다.

## global

노드의 **전역 객체**로 브라우저의 window와 같은 역할을 한다. js와 마찬가지로 메서드 호출시 global을 생략 가능하다.

### console

global안에 들어있는 객체로 디버깅을 위해 사용한다. console.log(), console.error() 등 자주 쓰이는 것들이 있고 console.time(레이블), console.timeEnd(레이블)로 코드 실행 시간을 측정할 수 있는 정도 알아두면 될 것 같다.

### 타이머

타이머 또한 global 안에 들어 있으며 브라우저의 setTimeout(), setInterval()을 가지고 있다.  
브라우저와 마찬가지로 이것들은 아이디를 반환하며 이 아이디를 인자로 clearTimeout(), clearInterval()을 호출하여 취소도 가능하다.

그리고 노드에서 **추가 제공**하는 setImmediate(), clearImmediate()가 있다. 콜백 함수를 즉시 실행하는(그리고 아이디로 취소하는) 기능을 가지고 있다.

## **filename, **dirname

노드는 파일 사이에 모듈로 관계를 맺는 경우가 많으므로 현재 파일 경로에 대한 정보를 제공한다.

- \_\_filename : 현재 파일의 경로와 파일명까지 나타낸다.
- \_\_dirname : 현재 파일의 경로를 나타낸다.

## module, exports, require

- module : 모듈을 만드는데 사용되는 객체
- exports : module.exports 와 같은 객체를 참조하는 객체. module.exports 대신 사용할 수 있으나 module.exports 와는 다르게 함수나 변수를 대입할 수 없고 반드시 객체처럼 구성해야 한다. **module.exports 와 동시 사용하는 것은 좋지 않다.**
- require : 인자로 받은 경로의 모듈을 불러오는 기능을 가진 함수.

- [ ] require.cahch(), require.main() 실습

### 순환 참조

서로 다른 모듈이 서로 require() 를 하게 되면 정상적으로 실행되지 않고 해당 모듈의 module.exports 를 **오류 없이 빈 객체로 만들기 때문에** 조심해야 한다.

### 노드에서 this의 바인딩은?

- 최상위 스코프에서 : module.exports 객체
- 함수 선언문 내부에서 : global 객체

## process

현재 실행되는 노드 프로세스에 대한 정보를 담고 있는 객체이다. 많이 쓰지는 않지만 몇 가지 중요한 것들이 있음.

- process.env : 시스템 환경 변소를 출력
- process.nextTick() : nextTick의 콜백 함수가 다른 콜백 함수들보다 우선적으로 처리된다. promise도 이렇게 작동한다.
- process.exit() : 호출시 실행중인 노드 프로세스를 종료한다.

# 03-2. 내장 모듈

노드에는 다양한 기능을 제공하는 내장 모듈들이 있다. 내장이므로 별도 설치는 필요없지만 이것은 모듈이기 때문에 **사용을 위해서는 먼저 require()로 불러와야 한다.**

## OS

운영체제의 정보를 제공하는 모듈

- os.cpus().length : 코어 개수 출력
- os.constants : 각종 에러, 신호에 대한 코드가 담겨 있음.

## Path

- [ ]

## url

인터넷 주소를 쉽게 조작할 수 있도록 도와주는 모듈이다.  
url 처리는 WHATWG 방식과, 노드에서 사용하는 방식 2가지가 있는데 url를 각 파트로 분해하는 방법의 차이가 있다.

### 분해와 조립

- URL 생성자 함수 : url 모듈 내에는 URL 생성자 함수가 있는데 이 함수에 url 주소를 넣어서 인스턴스를 만들면 WHATWG 방식으로 분해된 객체를 얻을 수 있다.
- url.parse() : 노드 방식으로 url 주소를 분해해서 객체를 얻고 싶다면 이 방법을 사용한다.

- url.format() : 위의 두 방식으로 분해된 url 객체를 다시 조립한다.

### searchparams

WHATWG 방식으로 url을 분해하면 search 부분을 searchparams 라는 유용한 객체로 반환한다.

![3-1](./code/ch03/3-1.png)

이 search 부분을 다룰수 있는 메서드를 제공한다.

### querystring

searchparamas가 없는 원래 노드 방식으로 url을 분해한 경우에 search 부분을 사용하기 쉽게 객체로 만들어주는 모듈이다.

- querystring.parse() : url의 query(부분만)를 인자로 받아서 객체로 분해한다.
- querystring.stringify() : 분해된 객체를 다시 조립한다.

## crypto

## util

## worker_threads

## child_process

# 03-3. 파일 시스템

## fs

파일 시스템에 접근하는 모듈이다.

# 03-4. 이벤트 & 예외 처리

노드는 싱글 스레드이므로 하나인 스레드가 멈추면 전체 프로세스가 멈추게 된다. 따라서 에외 처리의 중요성은 더욱 강조된다.
