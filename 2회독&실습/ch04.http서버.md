# 04. http 서버

서버는 클라이언트의 요청을 받고, 그에 따른 응답을 보내는 컴퓨터이다.  
따라서 서버 구축은 요청을 받는 부분과 응답을 하는 부분이 있고, 이것은 이벤트 방식 즉 요청에 대한 작업을 미리 이벤트 리스너로 등록해 둔다는 것을 의미한다.

## 포트

서버 내에서 프로세스를 구분하는 번호이다. 서버는 http 요청 대기만 하는데 아니라 다양한 작업을 하므로, 프로세스마다 포트를 다르게 할당하여 들어오는 요청을 구분할 필요가 있다.

포트 번호는 IP주소 뒤에 : 를 붙여서 사용하면 된다.

# HTTP

잠시 노드를 벗어나서 http 통신에 대하여 알아보아야 겠다. HTTP는 서버 - 클라이언트가 어떻게 메시지를 교환할지를 정해놓은 규약으로 통상 80번 포트를 사용한다.
따라서 http 서버를 구축한다는 것은, 이 방식에 따른 통신 방법으로 서버와 클라이언트가 메시지를 교환하겠다는 것으로 그 메시지는 어떻게 구성되어 있는지를 알 필요가 있다.

## HTTP 요청

HTTP 요청은 다음과 같은 정보들이 들어가게 된다.

- 요청 메서드 : 클라이언트가 수행하려는 동작을 적음 (GET, POST 등등...)
- 리소스의 경로 : 요청 메서드에 따라서 달라지며 URL 등으로 나타낸다.
- HTTP 버젼 : 남은 요청의 구조를 결정하므로 여기에 적어준다.
- 헤더 : 추가 정보를 전달하기 위해 작성한다. 대소문자 구분 없는 문자열 후에 : 을 적어서 작성하며, 우변에는 헤더마다 필요한 값이 들어간다. 예컨데 리소스의 타입을 추가로 전달할 때 쓰는 헤더는 다음과 같이 작성할 수 있다.

  ```
  Content-Type: text/html; charset=UTF-8
  ```

- 본문 : POST 등 몇 가지 특별한 요청을 보낼 때 작성한다.

## HTTP 응답

응답에는 다음과 같은 정보들이 들어가게 된다.

- HTTP 버전 :
- 상태 코드 : 성공 여부와 이유를 나타내는 3자리 숫자이다.
- 상태 메시지 : 결과에는 영향이 없고 클라이언트 사용자가 이해하기 쉽도록 짧은 글을 적는다.
- 헤더 : 요청과 마찬가지로 추가적인 정보 전달을 위해서 헤더를 작성할 수 있다.
- 본문 : 가져온 리소스를 포함하는 부분이다.

따라서 요청에 있는 저 요소들을 적절하게 해석하여, 응답의 내용인 상태 코드, 메시지, 헤더, 본문을 작성해서 돌려주는 것이 목표인 것이다.

## http 모듈

http 모듈은 서버를 구축할 수 있게 하는 내장 모듈이다. 따라서 1장에서 보았듯 별도 서버 설치 없이도 서버 구축이 가능하다. 예시를 하나 보자.

http 모듈로 서버를 여는 예제 코드이다. 실행한 후 localhost:8080으로 접속하면 (즉, 요청을 보내면) 요청에 따른 응답이 웹 페이지에 표시된다.  
listen 메서드는 서버는 여는 역할을 하고, res.writeHead 는 http 응답에 대한 정보를 기록하는 메서드로 위에서 살펴본 것 중에 상태코드 (200)와 헤더를 작성하는 부분임을 알 수가 있다. res.write 와 res.end 는 클라이언트에 보낼 데이터, 즉 본문(body)에 들어갈 것을 작성하는 메서드이며 res.end 는 응답을 종료하는 기능도 있다.

```js
const http = require('http');

http
  .createServer((req, res) => {
    res.writeHead(200, { 'Content-type': 'text/html; charset=utf-8' });
    res.write('<h1>hello wolrd!<h1>');
    res.end('<p>hello server!<p>');
  })
  .listen(8080, () => {
    console.log('8080번 포트에서 서버 대기 중');
  });
```

이처럼 http 모듈은 서버를 열고 http 응답을 작성하여 클라이언트에게 보낼 수 있는 메서드들을 가지고 있다.

### 상태 코드

res.writeHead 에서 작성했던 상태 코드는 응답의 성공 여부와 이유를 알려주는 http 응답의 구성 요소로, 3자리 숫자로 이루어져 있으며 첫 번째 자리 숫자에 따라서 범주화 되어 있다.

- 2xx : 성공을 알려주는 상태 코드이다. 200(성공), 201(작성됨) 등이 있다.
- 3xx : 다른 페이지로 이동하는 리다이렉션을 알리는 코드이다.
- 4xx : 요청 자체에 오류가 있을 때 표시된다.
- 5xx : 서버에 오류가 있을 때 보내지는 코드이다.

**오류가 나더라도 응답은 꼭 보내야지 클라이언트에서 기다리지 않는 다는 점을 기억하자!**

## REST와 라우팅

## 쿠키

클라이언트 요청에는 누가 요청을 보내는 것인지 알 수 없다는 단점이 있다. 이 문제를 해결하기 위해서 http 응답 헤더에는 쿠키라는 것을 보낼 수가 있다.

![4-1](./code/ch04/4-1.png)

Set-Cookie 라는 이름의 헤더를 작성하여 쿠키를 보낼 수 있으며 이 헤더의 값은 키-값의 형식을 가진 문자열로 작성된다.  
예컨대 http 응답에서 다음과 같이 작성될 수 있을 것이다.

```http
HTTP/2.0 200 OK
Content-Type: text/html
Set-Cookie: yummy_cookie=choco // 쿠키

[page content]
```

http 모듈에서는 다음과 같이 코딩하여 http 응답에 쿠키를 넣어줄 수 있을 것이다.

```js
res.writeHead(200, { 'Set-Cookie': 'yummy_cookie=choco' });
```

이렇게 쿠키를 전달하면, 웹 브라우저는 이 쿠키를 저장해 두었다가 다음에 http 요청을 하면 http 요청의 Cookie 라는 이름의 헤더에 저장된 쿠키를 동봉해서 보낸다. 서버는 요청에 들어있는 쿠키를 읽어서 사용자를 파악하는 것이 쿠키가 작동하는 방식이다.

```http
GET /sample_page.html HTTP/2.0
Host: www.example.org
Cookie: yummy_cookie=choco; // 쿠키
```

쿠키에는 다음과 같이 여러가지 옵션을 넣어 줄 수 있다.

```http
Set-Cookie: id=a3fWa; Expires=Thu, 21 Oct 2021 07:28:00 GMT; Secure; HttpOnly
```

- Expires : 만료 기한을 설정할 수 있다.
- secure : HTTPS 일 경우에만 쿠키가 전송되게 한다.
- HttpOnly : js에서 쿠키에 접근할 수 없게 한다.

이외에도 여러가지 옵션이 있어서 필요한 것을 사용하면 된다.

- [ ] 쿠키 실전

## 세션

쿠키는 웹 브라우저에 저장되므로 노출되어 있어서 민감한 정보를 담아두는 것이 적절하지 않고 또한 조작될 위험도 존재한다.  
이 문제를 해결하기 위해서 정보가 저장되는 장소를 웹 브라우저가 아닌 서버 내에 위치시키는 방법이 세션이다.

쿠키에 정보를 담아서 보내는 대신, 세션 아이디라는 변수를 대신 담아서 보내고 실제 정보는 세션 아이디와 연관시켜서 DB에 저장하거나 하면 된다. 그럼 쿠키에는 세션 아이디만 담겨 있으므로(꼭 세션 아이디를 쿠키에 넣어 전달해야 하는 것은 아니지만 편의상 많이 쓴다고 함) 정보 노출을 피할 수 있다.

나머지 방식은 쿠키와 동일하게 동작한다. 서버 자원을 사용하며 서버 처리가 추가로 들어가므로 응답 시간이 좀 더 걸리겠지만 보안 면에서 쿠키 방식보다 우수하다.

## https, http2

https 프로토콜은 SSL 이라는 것을 사용해 전송되는 데이터를 암호화해서 보내도록 하여 중간에 데이터를 가로챌 위험이 있는 http를 보완한 프로토콜이다.  
SSL이 적용된 웹 사이트는 주소창에 자물쇠가 있는 것으로 구분할 수도 있으며, 포트는 443번을 주로 사용한다.  
노드에서는 https 서버를 구축할 수 있는 https 모듈을 제공하는데, https 서버를 구축하려면 인증서를 먼저 발급 받아야 한다. 처음 서버를 열 때 인증서를 연결하는 부분만 제외하면 http 모듈과 같은 구조로 작성할 수 있다.

또한 노드는 요청과 응답 방식을 기존 http/1.1보다 개선한 http/2 프로토콜을 사용할 수 있으며 위에서 설명한 SSL 암호화를 같이 적용하는 http2 모듈도 지원하고 있다.  
이 모듈 또한 처음에 인증서를 연결하는 부분만 제외하면 http 모듈과 같은 방식으로 코딩할 수 있다.

## cluster

cluster 모듈은 싱글 프로세스로 동작하는 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈이다. 같은 포트를 공유하는 노드 프로세스를 여러개 둘 수가 있어서, 요청이 분산되어서 서버에 무리가 덜 가게 된다. 하지만 서로 다른 코어를 쓰게 되면 메모리를 공유하지 못하는 문제점도 있다.

```js
const cluster = require('cluster');
const http = require('http');

const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // 마스터 프로세스인지 확인
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork(); // 워커를 생산하는 메서드
  }
  cluster.on('exit', (worker, code, signal) => {
    // 워커 프로세스가 종료되었을 때의 이벤트 리스너
    console.log(`${worker.process.pid}번 워커가 종료되었습니다.`);
  });
} else {
  // 마스터 프로세스가 아닌 경우, 즉 워커 프로세스인 경우 일 할 내용을 적어준다.
  http
    .createServer((req, res) => {
      res.writeHead(200, { 'Content-type': 'text/html; charset=utf-8' });
      res.write('<h1>hello wolrd!<h1>');
      res.end('<p>hello server!<p>');
    })
    .listen(8080, () => {
      console.log('8080번 포트에서 서버 대기 중');
    });
}
```

워커 스레드와 유사한 구조를 가지고 있다. (하지만 워커 스레드는 한 프로세스 내에서 여러 개의 스레드를 사용하게 해주는 것임)  
클러스터에서는 마스터 프로세스와 워커 프로세스가 있고, 마스터 프로세스는 워커 프로세스를 만들고 요청이 들어오면 워커 프로세스에 분배를 해 준다.  
실질적으로 워커 프로세스가 일을 하게 된다.

같은 포트를 공유하는 프로세스가 여러 개 이므로, 하나의 워커 프로세스가 종료되어도 서버는 멈추지 않기 때문에 오류에 대항할 수 있는 방법이 되지만, 오류 자체를 해결하는 것이 더 중요한 일이다. 그럼에도 불구하고 만약의 상황을 대비해서 클러스터링을 적용하는 것이 좋다고 한다.
