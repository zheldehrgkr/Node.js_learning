# HTTP 서버 구축

http는 노드의 **내장 모듈**이다. 즉 따로 설치할 필요 없음. (1장의 웹 서버가 내장되어 있다는 게 이 말이었구나)
노드 실행 후 http라고 쳐서 정보를 확인해 볼 수 있었음.

```js
const http = require("http");
```

따라서 이렇게 시작하게 된다.

## 포트

서버 내에서 프로세스를 구분하는 번호.

- 이미 사용하고 있는 포트를 사용할 경우 에러 발생!
- 맥에서는 1024번 이하 포트 연결시 sudo를 붙여야함
- 80(http), 443(https), 3306(mysql)등 주로 쓰는 포트번호 들이 있음

### 기본 예시

```js
const http = require("http"); // http 모듈 불러오기
const port = 8080; // 포트 번호 설정

const server = http.createServer((req, res) => {
  // 서버를 만드는 http모듈의 메소드
  res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" }); // 이 정보는 헤더에 저장
  res.write("hello stranger!"); // 이 정보는 바디에 저장
  res.end("response closed");
});

server.listen(port);

server.on("listening", () => {
  console.log("서버 대기중");
});

server.on("error", (error) => {
  console.error(error);
});
```

- [x] .on의 listening 이벤트에 대한 내용이 없다? : 해결 이게 다른 모듈 net에서 가져온 거라 거기서 설명하고 있었음
- [ ] 그럼 net 모듈은 뭐지?

## http 상태 코드

브라우저가 서버 요청이 어떻게 처리되었는지를 알려주기 위해 헤더에 넣는 코드.

- 2xx : 성공을 알림
- 3xx : 리디렉션
- 4xx : 요청에 오류가 있음
- 5xx : 요청은 잘 되었지만 서버에 오류가 있을 때. (이게 뜨지 않게 프로그래밍 하자!)

무조건 응답을 보내야 한다. (에러가 발생하더라도!)

## http 메소드

- GET : 서버 리소스를 가져옴
- POST : 새로운 리소스 생성
- PUT : 리소스 치환 (일부 수정이 아닌 요청 바디로 교체하는 것이기 때문에 리소스 전체에 대한 내용을 보내야 함)
- PATCH : 리소스 수정 (요청에 수정할 부분만 넣어서 보내면 됨)
- DELETE : 리소스 삭제
- OPTIONS : 통신 옵션 설명

## REST

로이 필딩의 논문에서 소개되었고, http를 효율적으로 사용할 수 있는 구조를 제시한 것이고, 현대 웹에서 다들 이 가이드라인을 따르고 있기 때문에 잘 지켜야 하고, 어떻게 서버 리소스를 잘 표현할지에 대한 가이드라인이고...
뭔가 시원한 설명을 찾기가 어렵다 🤨

어쨋든 중요한 **설계 원칙**

- URI는 리소스를 표현하는데 집중한다. (명사로)
- 행위는 http 메서드로만 표현한다.

예컨대 유저 정보를 가져오고 싶다.

```text
GET /getuser/1 // uri에 행위가 들어가면 안된다. 그리고 정보를 잘 나타낼 수 있는 명사를 선택하자
GET /user/1 // 이렇게 명사로 나타내고 GET 메소드로부터 유저 정보를 얻는다는 추론을 할 수 있다.
```

이렇게 써야 아 어느 리소스에 어떤 행위를 하라는 요청이구나를 쉽게 알 수 있다.

- [ ] REST의 6가지 원칙에 대해서 공부하기
- [x] 프로젝트 2 리팩토링 : URI에 행위를 명시한 부분이 있었다. 이를 수정할 것

## 라우팅 예제

주소 체계를 만들었으면 실제로 그렇게 분기가 되게 서버를 구축해야 한다.
예제로 실습해보았고 req.method가 무엇인지에 따라서 if문으로 분기하고 또 각 메소드의 엔드포인트에 따라서 if문으로 분기하는 식으로 구성이 되어 있었다.

## 쿠키와 세션

### 쿠키

쿠키는 유효기간이 있는 키-값의 쌍인 문자열이며 헤더에 담겨 전송된다.  
서버에서 쿠키를 보내면 브라우저는 쿠키를 저장해두었다가 다음에 요청을 보낼 때 저장한 쿠키를 같이 보낸다.  
서버는 클라이언트를 추정할 수 있는 정보를 쿠키로 보내고, 추후에 클라이언트 측에서 요청을 보내면 동봉된 쿠키를 받아서 사용자가 누구인지 파악할 수 있다.

- 쿠키가 있는 경우 req.headers.cookie에 들어있다.
- 서버는 헤더를 작성할 때 (http 모듈에서는 res.writeHead()에서 Set-Cookie로 설정한다) 몇 가지 옵션을 넣을 수가 있다.

  - 이름=값 : 쿠키 설정
  - Expires=날짜 : '날짜'에 만료가 된다.
  - Max-age=초 : 해당 초가 지나면 쿠키가 만료된다. Expires 보다 우선된다.
  - Domain=도메인 : 쿠키가 전송될 도메인을 특정한다
  - Paht=URL : 쿠키가 전송될 URL을 특정할 수 있다.
  - Secure : HTTPS일 경우에만 쿠키가 전송된다
  - HttpOnly : js에서 쿠키에 접근할 수 없다. 보안의 이유로 권정된다.

- [ ] 저 도메인을 특정한다는 것이 잘 이해되지 않는다. 추가학습 필요

### 세션

쿠키는 브라우저에 노출이 되는 문제를 해결하는 때문에 세션 방식이 있다.  
세션 객체를 만들어서 세션 아이디를 키로, 쿠키를 값으로 저장한 뒤에 쿠키값 대신 세션 아이디로 소통하는 방법이다.  
세션 아이디를 제시하면 해당 객체의 값에 있는 쿠키를 검사해서 유효성을 판단하는 방식이다.  
세션 아이디를 전달하는 방법은 꼭 정해져 있는 것은 아니지만 쿠키로 전달을 하는게 간단하다고 한다.

## https, http2

https 모듈은 ssl 암호화가 추가된다. 이는 get,post 요청 시 오가는 데이터를 암호화해서 요청을 가로채도 내용을 알 수 없게 만든다.

아까 보았던 ssl 암호화에 http/2 프로토콜까지 사용할 수 있는 모듈이 http2 이다.

- [ ] http/1.1 과 http/2의 차이점 공부하기

## cluster

cpu 코어를 모두 사용할 수 있게 해주는 모듈이다.
이 부분이 조금 헷갈렸는데 나름 정리를 해보면 Node.js(정확히는 노드의 이벤트 루프)는 싱글 스레드이므로 프로세스에서 하나당 (조작할 수 있는) 스레드가 하나뿐이다.  
다만 cluster를 사용하면 남는 cpu 코어를 모두 사용해 '프로세스'를 여러가 만들어 각 프로세스가 요청을 분산 처리하게 되어 서버 부담을 줄일 수 있다.  
즉 하나의 프로세스당 하나의 스레드를 가지는 싱글 스레드와는 별개의 문제라는 것이다.

여러개의 프로세스가 존재하므로 오류가 생겨서 서버가 꺼져도 프로세스 갯수만큼을 버틸 수 있다.  
물론 오류의 근본적인 해결책이 아니기 때문에 이것에 의존해서는 안 되지만 만약을 대비해서 클러스터링을 적용해 두는 것이 좋다고 한다.

- [ ] 그럼 이 기능을 사용해서 서버를 돌린다면 '해당 컴퓨터에서 하는 다른 작업'들이 느려지게 되는 것일까?
- [ ] worker_threads, child_process 와의 비교와 추가 학습

# 실습 관련 체크리스트

## 4-2장

- [ ] req.url은 어디부터 시작하는 것인가. starsWith에서 어째서 /user/로 인자를 줄 수 있는지? URL 처음시작인 http가 아니고?
- [ ] string.startsWith(), string.split() 익히기
- [ ] JSON.parse()뒤에 .name 붙는 이유, 일단 파싱 결과값은 객체로 리턴되므로 프로퍼티 접근인 건 알겠는데 .name 프로퍼티가 왜 있는지 모르겠음
- [ ] req.on().on()으로 이어붙이면 작동하지 않는 이유
